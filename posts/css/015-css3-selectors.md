# CSS3 选择器selectors—模块级别3

## 摘要

选择器就是匹配在树中元素的模式，且形成了用来选择XML文档中的节点的技术之一。选择器优化了HTML和XML的使用，且被设计成了可用的性能关键型代码。

CSS（层叠样式表）是一个描述HTML和XML文档在屏幕上，纸张上，语言中等渲染的语言。CSS使用选择器来绑定文档中的元素的样式属性。

文本档描述的选择器在CSS1和CSS2中已经存在了，且详细介绍了CSS3的新的选择器以及其他语言可能需要的。

选择器定义如下函数：

	expression * element → boolean

那就是给定一个元素和一个选择器，本规范定义这个元素是否匹配这个这个选择器。

实际上那些表达式也能用于选择一组元素或者一组元素中的一个单独元素，通过跨越在子树中所有的元素来计算这个表达式。STTS（Simple Tree Transformation Sheets单独树转换表）——一种为了转换XML树的语言——使用这个机制。

<!--more-->

## 简介

选择器级别1和选择器级别2定义了在CSS1和CSS2中分别定义的选择器功能的子集。

### 依赖

本规范的一些功能是特定于CSS的，或者说部分限制或者规则限制于CSS。在本规范中，这些已经在CSS2.1的条目中描述过了。

### 术语

本规范的所有文本都是标准的，除了例子，注意和明确标记为非标准的段落。

额外的术语在CSS2.1中[定义](http://www.w3.org/TR/CSS21/conform.html#defs)部分定义的了。例子文档源代码和片段都是以XML（XML10）或者HTML（HTML40）语法给定的。

### 和CSS2的不同

_本段仍是非标准的。_

CSS2和CSS3选择器之间主要的不同是：

* 基本定义列表（选择器，组选择器，简单选择器等）已经变了；在CSS2中作为简单选择器的部分现在称为一系列简单选择器，且“简单选择器”条目现在用于这个系列的组件

* 元素的类型选择器，通用选择器和属性选择器现在允许有可选的命名空间组件

* 介绍了新的连接符

* 包含子链匹配属性选择器和新的伪类的新的简单选择器

* 新的伪元素和伪元素的"::"约定的介绍

* 重写了语法

* 规范中增加了集合选择器和实际上每一个规范已经支持了的定义系列选择器的档案

* 选择器现在是CSS3的一个模块了，并且是一个独立的规范；其他的规范现在能引用本文档独立的CSS

* 规范现在有了他自己的测试体系

## 选择器

_本段仍是非标准的；他只是下边段落的集合。_

一个选择器代表了一种结构。这个结构能作为确定在文档树中的哪些元素匹配选择器的条件使用，或者作为HTML或者XML片段相应的结构的平面描述。

选择器可以从一个简单元素名到丰富的上下文表示变动。

下边的表格汇总了选择器语法：

![选择器汇总](https://raw.githubusercontent.com/dolymood/blog/master/pics/005.png)

_PS：顺便附上一张来自[w3school](http://www.w3school.com.cn/cssref/css_selectors.asp)的表格：_

![选择器汇总](https://raw.githubusercontent.com/dolymood/blog/master/pics/006.png)

每一个选择器的含义就是源自于上边的表格中第一列匹配Meaning列的每一个单元格内容。

## 大小写敏感性

在ASCII范围内的所有的选择符语法都是不区分大小写的（也就是[a-z]和[A-Z]是相等的），除了不在选择器控制下的部分。文档语言元素名，属性名和在选择器中的属性值的大小写敏感性取决于文档语言。例如，在HTML中，元素名字就是不区分大小写的，但是在XML中就是区分大小写的。命名空间的大小写敏感性是在[CSS3命名空间](./014-css3-namespace.md)中定义的。

## 选择器语法

一个选择器是由按连接符分隔一个或者多个简单选择器序列组成的链。一个伪元素可以附在一个选择器的最后一个简单选择器序列之后。

一个简单选择器序列是一个不被连接符隔开的简单选择器组成链。他往往以类型选择器或者通用选择器开头。在这个序列中不允许其他的类型选择器或者通用选择器。

一个简单的选择器是一个类型选择器、通用选择器、属性选择器、类选择器、ID选择器或者伪类。

连接符是：空格，大于号>，加号+和波浪号~。空白可以出现在一个连接符和这个简单选择器周围。只有字符空格space（U+0020），tab（U+0009），换行（U+000A），回车（U+000D）和换页（U+000C）在空格中出现。其他字符，例如em-space（U+2003）和表意空格ideographic space，永远不能成为空白的一部分。

被一个选择器代表的文档树元素是这个选择器的匹配元素subjects。一个由简单选择器组成的序列而成的选择器代表了符合他要求的任何元素。在序列的最前边插入另一个简单选择器序列和一个连接符来增加额外的匹配约束，这样一个选择器的匹配元素通常是最后一个简单选择器序列所代表的元素的一个子集。

一个空的选择器（不包含任何简单选择器序列，伪元素）是一个无效的选择器。

选择器中的字符能用反斜杠通过CSS相同的转义规则转义。

某些选择器支持命名空间前缀。这种通过命名空间前缀被声明的机制应该通过使用选择器的语言来指定。如果这个语言没指定命名空间前缀声明机制，那么没有前缀被声明。在CSS中，命名空间前缀用`@namespace`规则声明。

## 选择器组

用逗号分隔的选择器列表代表了在列表中每一个单独的选择器选择的元素的并集。例如，在CSS中当有多个选择器共享相同的声明的时候，他们可以组成逗号列表。空白可以出现在逗号周围。

> CSS例子：

> 在这个例子中，我们浓缩下边的三条独立声明为一条。因此，

```css
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }
```

> 是等于：

```css
h1, h2, h3 { font-family: sans-serif }
```

__警告：__这个例子中是相等的，因为所有的选择器都是有效的选择器。如果仅仅只有一个是无效的，那么整个的选择器组会是无效的。这会使得三个头元素的规则无效，对于前边的那个情况来说只有那个无效的头规则是无效的。

> 无效的CSS例子：

```css
h1 { font-family: sans-serif }
h2..foo { font-family: sans-serif }
h3 { font-family: sans-serif }
```

> 是不等于：

```css
h1, h2..foo, h3 { font-family: sans-serif }
```

> 因为上边的选择器（h1, h2..foo, h3）是完全无效的，整个的样式规则被丢弃。（当选择器没有分组，只有h2..foo的规则会被丢弃）

## 简单选择器

### 类型选择器

类型选择器就是文档语言元素类型使用CSS等同的名字语法写的名字。类型选择器代表了文档树中元素的类型的实例。

> 例子：

> 下边的选择器代表了文档树中的h1元素：

```
h1
```

#### 类型选择器和命名空间

类型选择器允许可选的命名空间元件：一个已经被显示声明的可以插在用命名空间分隔符竖线（U+007C，|）分隔的元素名之前的命名空间前缀。

命名空间元件可以是空的（在命名空间分隔符之前没有前缀）表明这个选择器只能代表没有命名空间的元素。

星号*可以当做命名空间前缀使用，表明选择器代表了任何命名空间中的元素（包括没有命名空间元素）。

没有命名空间元件的元素类型选择器（没有命名空间分隔符）代表了不用考虑元素命名空间的元素除非有为了命名空间选择器声明的默认的命名空间。如果声明了一个默认的命名空间，那么那样的选择器只会代表了在默认命名空间中的元素。

一个包含了一个没有为命名空间选择器而声明的命名空间前缀的类型选择器是无效的选择器。

在一个识别命名空间的客户端中，元素类型选择器的部分名字（如果存在在命名空间分隔符之后的部分）会只匹配这个元素的合法名字的本地部分（也就是本地名字）。

总结：

* __ns|E__

	元素名字是E且在命名空间ns中

* __*|E__

	元素名字是E且在任何命名空间中，包括哪些没有命名空间的

* __|E__

	元素名字是E且不在命名空间中

* __E__

	如果没有为了选择器声明默认的命名空间的话，这是和*|E相等的。其他情况的话他是和ns|E相等的，ns就是默认的命名空间。

> CSS例子：

```css
@namespace foo url(http://www.example.com);
 foo|h1 { color: blue }  /* first rule */
 foo|* { color: yellow } /* second rule */
 |h1 { color: red }      /* ...*/
 *|h1 { color: green }
 h1 { color: green }
```

> 第一条规则（不包括`@namespace`at规则）会匹配在`http://www.example.com`命名空间中的`h1`元素。

> 第二条规则会匹配在`http://www.example.com`命名空间中的所有元素。

> 第三条规则会匹配没有命名空间的`h1`元素。

> 第四条规则会匹配在任何命名空间中的`h1`元素。

> 最后那条规则会和第四条规则相等，因为没有定义默认命名空间。

### 通用选择器

通用选择器，以一个CSS合法名字和一个星号*写法作为本地名字，代表了任何元素类型的合法名字。如果没有为了选择器指定了默认命名空间的话，他代表了再文档树中中任何命名空间中的任何单个元素。如果指定了默认命名空间，请看下边的‘通用选择器和命名空间’。

如果一个被*代表了的通用选择器不是一系列简单选择器组成的选择器的唯一的元件或者之后立即跟着一个伪元素，那么*可以忽略且通用选择器暗中存在的。

> 例子：

* > *[hreflang|=en]和[hreflang|=en]是相等的，

* > *.warning和.warning是相等的，

* > *#myid和#myid是相等的。

#### 通用选择器和命名空间

通用选择器允许一个可选的命名空间元件。按照如下使用：

* __ns|*__

	在命名空间ns中的所有元素

* __*|*__

	所有元素

* __|*__

	没有命名空间的所有元素

* __*__

	如果没有指定默认的命名空间的话，这是和*|*相等的。其他情况的话他是和ns|*相等的，ns就是默认的命名空间。

### 属性选择器

选择器允许一个元素的属性表示。当一个选择器用于一个表达式来匹配一个元素时，如果那个元素有属性且匹配属性选择器所表示的属性，那么属性选择器必须考虑是否匹配这个元素。

#### 存在属性和值选择器

CSS2中介绍了四种属性选择器：

* __[att]__

	代表了一个元素有att属性，但是不管这个属性的值

* __[att=val]__

	代表了一个元素有att属性，且值是val

* __[att~=val]__

	代表了一个元素有att属性，且值是空格分隔的单词列表，他们其中之一是val。如果val包含空格，他永远不会代表什么东西。如果val是空字符串，也不会代表任何东西。

* __[att|=val]__

	代表了一个元素有att属性，且值是完整的val或者以val开头且之后紧跟着-（U+002D）。这主要是为了允许语言子码subcode作为在[BCP 47](http://www.rfc-editor.org/rfc/bcp/bcp47.txt)中所描述的那样匹配。对于lang（或者xml:lang）语言子码匹配，请看‘语言伪类:lang’。

属性值必须是CSS标识符或者字符串。在选择器中的属性名和值的大小写敏感性是取决于文档语言的。

> 例子：

> 接下来的属性选择器代表了一个`h1`元素，他带有title属性，不管他的值是什么：

```css
h1[title]
```

> 接下来的例子，选择器代表了一个`span`元素，他的class属性的明确的值是example：

```css
span[class="example"]
```

> 多个属性选择器能用来代表一个元素的多个属性，或者相同属性的多个条件。这里，这个选择器代表了一个`span`元素，他的hello属性的值是Cleveland且他的goodbye属性的值是Columbus：

```css
span[hello="Cleveland"][goodbye="Columbus"]
```

> 接下来的CSS规则阐述了`=`和`~=`之间的区别。第一个选择器会匹配，例如，一个`a`元素，rel属性的值是`copyright copyleft copyeditor`。第二个选择器只会匹配一个`a`元素，他的href属性的值是确切的`http://www.w3.org/`

```css
a[rel~="copyright"] { ... }
a[href="http://www.w3.org/"] { ... }
```

> 下边的选择器代表了一个`a`元素，他的hreflang属性值是fr。

```css
a[hreflang=fr]
```

> 下边的选择器代表了一个`a`元素，他的hreflang属性值是以en开头，包含en, en-US和en-scouse：

```css
a[hreflang|="en"]
```

> 下边的选择器代表了一个`DIALOGUE`元素，当他的character属性值是下边两个之中的一个时：

```css
DIALOGUE[character=romeo]
DIALOGUE[character=juliet]
```

#### 子链匹配属性选择器