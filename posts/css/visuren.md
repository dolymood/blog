## CSS 可视化格式模型（Visual formatting model）

### 可视化格式模型简介

这一章以及下一章来描述可视化格式模型：用户代理针对于可视化媒介是怎样处理文档树的。

在可视化格式模型中，在文档树中的每一个元素会通过盒模型生成0个或者多个盒子。这些盒子的布局是这样管理的：

* 框的尺寸和类型。

* 定位体系（普通流、浮动float、和绝对定位）。

* 文档树中的元素之间的关系。

* 额外的信息（例如，viewport的大小、图片的固有尺寸等等）。

<!--more-->

本章以及下一章中定义的属性是应用在‘连续媒体’和‘分页媒体’上的。然而，当应用到分页媒体上的时候，margin属性的意义会有所不同。

可视化格式模型不会涉及格式化的所有细节（方面）。本规范中不包括那些符合规范的用户代理们的不同行为的那些格式化问题。

#### 视口 viewport

连续媒体的用户代理通常会提供给用户一个viewport，用户可以用来查阅文档。当viewport的大小发生改变的时候，用户代理可能会改变文档的布局。

当viewport比文档渲染您所需的画布区域小的时候，用户代理应该提供一个滚动条。每一个画布上最多有一个viewport，但是用户代理可以渲染多个画布。

#### 包含块

在CSS2.1中，很多的盒子的定位和尺寸的计算都取决于一个矩形的边界，这个矩形就是包含块。一般来说，生成的盒子扮演者他的子孙盒子的包含块的角色；我们称：一个盒子为他的子孙节点创建了包含块。

每一个盒子都相对于其包含块摆放，但是不会被包含块限制。他可能会溢出（overflow）。

在下一章中将会讨论包含块的细节。

### 控制盒子的产生

接下来的段落将会描述在CSS2.1中有的盒子类型。从部分角度来说，一个盒子的类型影响了他在可视化格式模型中的行为。下边所描述的display属性，决定了一个盒子的类型。

#### 块级元素（Block-level elements）和块盒（block boxes）

块级元素是源文档中的那些被可视化格式化为盒状的元素。这些display属性可以使得一个元素是块级的： 'block', 'list-item' 和 'table'。

块级盒是在一个BFC（块级格式化上下文）中的盒子。每一个块级元素会生成一个包含着子孙盒子的主块级盒（主盒），并且生成内容且这个盒子会参与任何定位方案。一些块级元素除了主盒外可能还会生成额外的盒，例如：'list-item'元素。这些额外的框相对于主盒摆放。

除了table盒子（将会在后边的章节介绍）和替换元素，一个块级盒子一般也是一个块容器盒。一个块容器盒要么只包含块级盒，要么只包含创建了IFC（inline formatting context 行内级格式化上下文）的行内级盒。并不是所有的块容器盒就是块级盒：非替换的inline blocks和非替换的table cells是块容器，但是却不是块级盒。块级盒同样是块容器的就成为块级盒（块盒）。

这三个术语“块级框”，“块容器盒”和“块盒”有时会清晰的简称为“块”。

#### 匿名块盒

在一个像这样的文档中：

```html
<DIV>
  Some text
  <P>More text
</DIV>
```

(DIV和P的display都是block)，DIV中同时出现了行内内容和块内容。为了更容易的格式化，我们假定围绕着“Some text”有一个匿名块盒。

![匿名块盒](http://www.w3.org/TR/CSS21/images/anon-block.png)

换句话说：如果一个块容器盒里边有一个块级盒，那么我们强制其内部只有块级盒。

当一个行内盒包含着一个在普通流中的块级盒的时候，这个行内盒（和他的在相同线盒中的行内祖先们）会在块级盒周围断掉（和任何的连续的或者仅仅只是被空白white space和/ 或者不在普通流中的元素分开的同级块级兄弟们），被拆分成两个盒子（及时一边是空的），分别在块级盒的两边。这个线盒在断掉之前和之后的线框被匿名的块盒包着，并且这个块级盒成了那些匿名盒的兄弟。当这样的行内盒被相对定位影响到了，因此产生的任何换算也会影响包含在这个行内盒的块级盒。

_这种模式会被应用到下边的示例中：_

```css
p    { display: inline }
span { display: block }
```

且在HTML文档中是这样的：

```html
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HEAD>
<TITLE>Anonymous text interrupted by a block</TITLE>
</HEAD>
<BODY>
<P>
This is anonymous text before the SPAN.
<SPAN>This is the content of SPAN.</SPAN>
This is anonymous text after the SPAN.
</P>
</BODY>
```

_这个P元素包含着一个在一个块级元素之前的匿名文本区块C1和在其之后的匿名文本区块C2。结果上来看，BODY的块级盒，包含了一个围绕着C1的匿名块盒，SPAN块盒和另外一个围绕着C2的匿名块盒。_

匿名盒的属性是继承自最近的非匿名盒（例如之前的例子中的匿名块盒，他最近的非匿名盒就是DIV这个盒子）。非继承性的属性会有他们的初始值。例如，匿名盒的font就会继承自DIV，但是margin的值将会是0。

一个元素生设置了属性导致产生匿名块盒同样适用于其内容。例如，如果在上边的例子中，如果P元素设置了边框，那么border就会围绕着C1和C2绘制。

![示例结果](https://github.com/dolymood/blog/raw/master/pics/001.png)

匿名块盒在计算相对于他的百分比的值的时候会被忽略掉：利用最近的非匿名的父级（祖先）框替换。例如，上边的例子中，如果在DIV内的匿名块盒的孩子需要知道他的包含块的高height去计算一个百分比的高的话，那么他就会使用由DIV格式化出的包含块的高而不是匿名块盒的。

#### 行内级元素和行内盒

行内级元素就是在源文档中的那些不会形成新的内容块的元素；内容成行分布。这些display的属性会使得一个元素行内级：'inline', 'inline-table', 和 'inline-block'。行内级元素生成行内级盒（inline-level boxes），这些盒子在一个行内格式化上下文中（IFC）。

一个行盒是一个既是行内级并且它的内容在一个IFC中的盒子。一个非替换元素，假设说display属性是inline的话，那么就会生成一个行盒。是行内级盒但是不是行盒（例如替换的行内级元素，inline-block元素和inline-table元素）被称作‘原子行内级盒（atomic inline-level boxes）’，因为他们在他们的IFC中作为单独的不透明的盒子存在。

##### 匿名行盒

在一个块容器元素（不是在一个行内元素中）中直接包含的任何文本必须当成一个匿名的行内元素对待。

在一个文档中的HTML是类似于这样的：

```html
	<p>Some <em>emphasized</em> text</p>
```

P生成一个块盒，在其内部有几个行内盒。EM生成一个行盒，但是其他的盒都是P生成的行盒。他们被称作匿名行盒，因为他们并没有被行内级元素包裹。

这样的行盒从他们的父块盒上继承可继承的属性。不可继承的属性将会有他们的初始值。在这个例子中，匿名盒的颜色是继承自P的，但是背景就会是透明的。

根据white-space的属性，折叠了的空白内容是不会产生任何匿名行盒的。

如果上下文中匿名盒的意义清楚的话，在本规范中，不管是匿名的行盒还是匿名的块盒都能简单的称为匿名盒。

当格式化table的时候会遇到更多的匿名盒类型。

#### display属性

* __display__
	
	_值：_  inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit

	_初始化：_ inline

	_应用在：_ 一切元素

	_可继承：_ 不可以

	_百分比：_ 不可用

	_媒介：_ 所有媒介

	_计算值：_ 依赖于文本

这个属性的值有一下的意思：

* __block__
	
	一个元素可以生成一个块盒。

* __inline-block__
	
	一个元素可以生成一个行内级块容器。在其内部被格式化为一个块盒且这个元素本身是被格式化为一个原子行级块。

* __inline__
	
	一个元素可以生成一个或者多个行盒。

* __list-item__
	
	一个元素（在HTML中的LI）可以生成一个主块盒和一个标记盒。

* __none__
	
	这个值导致元素不会出现在格式化结构中。也不会生成任何的盒，这个元素以及他的内容完全从格式化的结构中的移除掉。这种行为不能被他的子孙的display属性覆盖掉。

	请注意display是none的元素不会创建一个可视的盒；他根本就不创建盒。注意和visibility的区别。

* __table, inline-table, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, 和 table-caption__
	
	一个元素可以表现的像一个table元素（在后边的章节中会详细介绍table）。

计算值和指定值是一样的，除了定位了的和浮动了的元素以及根元素。针对于根元素来说，计算值的变化会在稍后的段落（display、position和float之间的关系）中介绍。

需要注意的值display的初始值是inline，在用户代理中的默认样式表可能会覆盖这个值。

_下边有关于display属性的几个例子：_

```css
p   { display: block }
em  { display: inline }
li  { display: list-item } 
img { display: none }      /* Do not display images */
```

### 定位体系

在CSS2.1中，一个盒可以根据三种定位体系布局：

1. 普通流。在CSS2.1中，普通流包括块级盒的块格式化，行内级盒的行格式化以及块级和行级的相对定位。

1. 浮动。在浮动模式中，一个盒首先按照普通流去布局，然后脱离出普通流并且尽可能的向左或向右偏移。内容可以沿着浮动边排列。

1. 绝对定位。在绝对定位模式中，一个盒完全从普通流中移除并且根据其包含块定位。

一个元素如果浮动了、绝对定位了或者是根元素，那么他叫做脱离（普通）流。如果不是脱离流的话，就叫做在流中（普通）。A元素的流由A以及在其流中的元素（这些元素的最近的脱离流的祖先是A）组成的。

#### 选择定位体系：'position'属性

在CSS2.1的定位算法中规定的position和float属性是用来计算一个盒的位置（position）的。

* __position__
	
	_值：_  static | relative | absolute | fixed | inherit

	_初始化：_ static

	_应用在：_ 一切元素

	_可继承：_ 不可以

	_百分比：_ 不可用

	_媒介：_ 可见媒介

	_计算值：_ 和指定值一样

这个属性的值有以下意思：

* __static__
	
	这个盒是一个普通的盒，根据普通流布局。top、right、bottom和left属性是无效的。

* __relative__
	
	这个盒根据普通流布局（叫做在普通流中的位置）。然后这个盒会偏移出他的原本的位置。当盒B是相对定位的，紧邻其后的盒的计算就像B没有便宜一样。在table-row-group, table-header-group, table-footer-group, table-row, table-column-group, table-column, table-cell, 和table-caption元素的position:relative是无效的。

* __absolute__
	
	这个盒的位置（可能大小）是由top、right、bottom和left属性确定的。这些属性的偏移是根据其包含块的。绝对定位的盒是从普通流中脱离的。这意味着他对紧邻其后的同级元素没有影响。同样的，尽管绝对定位的盒有margin，但是不会和其他的margin折叠。

* __fixed__
	
	这个盒的位置是通过绝对定位的模式，但是，这个盒需要根据一些参考来固定。和absolute模式一样，他的margin不会和其他的margin发生折叠。在手持设备、投影、屏幕、打字机以及电视的媒介类型的情况下，这个盒子是根据viewport固定的（不会随着滚定移动）。在打印的媒介类型的情况下，这个盒子在每一张上都会渲染，并且是根据page盒来固定，即使page是穿过一个viewport的。而其他的媒介类型，没啥效果。作者可以用依赖媒介的方式去指定fixed。就像：

	```css
	@media screen { 
	  h1#first { position: fixed } 
	}
	@media print { 
	  h1#first { position: static }
	}
	```

	用户代理必须不能对绝对定位的盒分页。

在根元素上，用户代理可以将position看成是static的。

#### 盒偏移：top、right、bottom、left

一个元素的position属性如果不是static的话就可以说他是一个定位（positioned）元素。定位元素会生成定位盒，通过下边的四个属性进行布局：

* __top__
	
	_值：_  <值length> | <百分比percentage> | auto | inherit

	_初始化：_ auto

	_应用在：_ 定位元素

	_可继承：_ 不可以

	_百分比：_ 根据其包含块的高

	_媒介：_ 可见媒介

	_计算值：_ 如果指定了长度，那么就转换成绝对长度；如果指定了百分比，就是指定的值；其他情况就是auto。

这是属性指定了绝对定位了的盒的top margin边界到他的包含块的上边界有多远。对于相对定位了的盒，就是根据其自身的上边界进行偏移。

* __right__
	
	_值：_  <值length> | <百分比percentage> | auto | inherit

	_初始化：_ auto

	_应用在：_ 定位元素

	_可继承：_ 不可以

	_百分比：_ 根据其包含块的宽

	_媒介：_ 可见媒介

	_计算值：_ 如果指定了长度，那么就转换成绝对长度；如果指定了百分比，就是指定的值；其他情况就是auto。

和top类似，但是是指定了绝对定位了的盒的right margin边界到他的包含块的右边界有多远。对于相对定位了的盒，就是根据其自身的右边界进行偏移。

* __bottom__
	
	_值：_  <值length> | <百分比percentage> | auto | inherit

	_初始化：_ auto

	_应用在：_ 定位元素

	_可继承：_ 不可以

	_百分比：_ 根据其包含块的高

	_媒介：_ 可见媒介

	_计算值：_ 如果指定了长度，那么就转换成绝对长度；如果指定了百分比，就是指定的值；其他情况就是auto。

和top类似，但是是指定了绝对定位了的盒的bottom margin边界到他的包含块的下边界有多远。对于相对定位了的盒，就是根据其自身的下边界进行偏移。

* __left__
	
	_值：_  <值length> | <百分比percentage> | auto | inherit

	_初始化：_ auto

	_应用在：_ 定位元素

	_可继承：_ 不可以

	_百分比：_ 根据其包含块的宽

	_媒介：_ 可见媒介

	_计算值：_ 如果指定了长度，那么就转换成绝对长度；如果指定了百分比，就是指定的值；其他情况就是auto。

和top类似，但是是指定了绝对定位了的盒的left margin边界到他的包含块的左边界有多远。对于相对定位了的盒，就是根据其自身的左边界进行偏移。

这四个属性的值有以下的这几种意思：

* __<长度length>__
	
	偏移相对的边界的一个固定的值。负值也是可以的。

* __<百分比percentage>__
	
	偏移的值死相对于包含块的宽或者高计算的。负值也是可以的。

* __auto__
	
	对于非替换元素，这个值的效果取决于和其相关的属性的值是auto一样。详情参见‘绝对定位了的非替换元素的宽和高’段落。针对于替换元素，这个值的效果只取决于被替换的内容的原始尺寸。详情参见‘绝对定位了的替换元素的宽和高’段落。

### 普通流

在普通流中的盒属于同一个格式化上下文（可能是块级也可能是行级，但是不会都是）。块盒参与块级格式化上下文。行内盒参与行内格式化上下文。

#### BFC 块级格式化上下文

不是块盒的浮动元素、绝对定位元素、块容器（例如inline-block table-cell table-caption）元素，以及overflow不是visible的块盒会给他们的内容创建新的BFC。

在一个BFC中，盒是从其包含块的顶部一个挨着一个在垂直方向上布局的。两个在垂直方向上相邻的的盒子之间的间距是由margin属性确定的。在同一个BFC中的两个毗邻的块级盒在垂直方向的margin会发生折叠。

在一个BFC中，每一个盒的左外边挨着其包含块的左边界（如果是从右到左的格式化的话，挨着右边）。即使存在浮动也是如此（尽管一个盒的线盒会由于浮动而收缩），除非这个盒创建了新的BFC（在这种情况下盒本身可能由于浮动而变得更加狭窄）。

#### IFC 行内格式化上下文

在一个IFC中，盒是从其包含块的顶部一个挨着另一个在水平方向上布局的。在这些盒的水平方向上的margin、border以及padding都是有效的。盒可以通过几种不同的方式在垂直方向上对齐：他们的top或者bottom对齐或者他们里边的文本的baseline（基线）对齐。包含着盒的矩形区域，会形成一条线，称作线盒。

一个线盒的宽是由包含块和浮动出现决定的。一个线盒的高是由在‘行高计算’段落中的规则决定的。

一个线盒的高往往对于其包含的所有盒是足够的。然而，他可能要比他包含的内容中的最高的盒的高还要高（例如以基线对齐的盒）。当一个盒B的高比包含着他的线盒的高要低的时候，线盒中的B的垂直对齐就由vertical-align这个属性决定。当多个行级盒在水平方向上无法放在一个单独的线盒中时，他们就会被分配在两个或者多个垂直堆叠的行盒中。因此，一个段落就是行盒在垂直方向上堆叠形成的。行框是不会存在垂直方向上的分割（除非其他地方规定了）和重叠的。


