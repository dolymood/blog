## CSS3 变量（CSS中为层叠变量的自定义属性———模块级别1）

### 摘要

这个模块介绍了作为一个全新的原生的被所有的CSS属性接受的值类型的层叠变量，且用自定义属性定义他们。CSS是一个描述结构化文档（例如HTML和XML）在屏幕上、纸张上、在语音中等等渲染的语言。

### 简介

_本段仍不是标准的。_

大型文档或者应用（以及那些即使是小的）能包含相当多的CSS。在很多的CSS文件中的值会是重复的数据；例如，一个网站可以确立一个颜色体系且整个网站在重用3到4个颜色值。变更这个数据是很困难的且容易出错，因此他在CSS文件（可能是多个CSS文件）中是分散着的，且查找替换并不可靠。

本模块介绍了以自定义属性广知的自定义作者定义属性家族，这允许作者给一个属性通过一个作者自己选择的名字和var()函数来指定任意的值（这允许作者之后在文档的其他地方给其他属性使用这些值）。这使得阅读大型的文件的时候更容易，因为看似无意义的值现在是有了具体含义的名字，且使得修改这样的文件更容易且不易出错，因为在自定义属性中只需要改变这个值一次，且这个改变会自动传播到所有使用这个变量的地方。

<!--more-->

### 定义自定义属性：--*属性家族

本规范定义了一个称为自定义属性（除了其他方面）的开放式的设置属性，用于定义var()函数的替代值。

* __--*__
	
	_值：_  <任意值any-value>

	_初始化：_ （没有，看其他段落）

	_应用在：_ 所有元素

	_可继承：_ 可以

	_媒介：_ 所有媒介

	_计算值：_ 用变量替换指定值（但是参见‘无效变量invalid variables’）

	_可动画：_ 不可以

一个自定义属性是以两个-开始的任意名字，像'--foo'。<自定义属性名custom-property-name>的生产production和这（他是以任何以两个-开始的可用的标识符）是对应的。自定义属性是对作者和用户单独使用的；CSS永远不会给他们一个超出这里所给出的意义。

_例子1：_

> 自定义属性定义变量，通过var()记法引用，能应用在多种用途。例如，一个设计上页面自始至终使用一小系列颜色能在自定义变量中存储这些颜色值，在用变量使用它们：

```css
:root {
  --main-color: #06c;
  --accent-color: #006;
}
/* The rest of the CSS file */
#foo h1 {
  color: var(--main-color);
}
```

> 命名提供了一个颜色的助记符，避免了在颜色代码中很难认出的错误（错别字），且如果一旦主题颜色变话了，只需在修改一个简单的地方而不是需要在web页面中跨越多个样式表来修改。

不像其他的CSS属性，自定义属性命名是区分大小写的。

_例子2：_

> '--foo'和'--FOO'都是可用的，他们是不同的属性——使用'var(--foo)'将会引用第一个，而使用'var(--FOO)'将会引用第二个。

自定义属性不会被[all](http://www.w3.org/TR/css3-cascade/#propdef-all)属性重置。_我们可能会在未来定义一个属性来重置所有的变量。_

[CSS通用关键词](http://www.w3.org/TR/css3-values/#css-wide-keywords)也能在自定义属性中使用，和其他属性有同样的意义。

> 注意：那是他们在层叠值时间解释为正常，且他们不是作为自定义属性的值保存的，因此不替换响应的变量。

> 注意：由于当前模块关注于自定义属性利用var()函数来使用创建“变量”，他们也能作为真实的自定义属性使用，通过脚本解析和执行。希望能在CSS扩展[CSS-EXTENSIONS](http://dev.w3.org/csswg/css-extensions/)中会详述这些使用例子且使得他们更容易做。

#### 自定义属性值语法

自定义属性允许的语法是非常宽松的。<任意值any-value>的生产production匹配任何一个或者多个标记tokens序列，只要序列中不包含<坏字符串标记>，<坏的URL标记>，不匹配的<<)-标记token>>，<<]-标记token>>，或<<}-标记token>>，或顶层<分号标记>标记或< delim-token >的值为"!"标记。

> 注意：这个随着CSS语法规则的定义指出了一个自定义属性值永远不能包含一个不匹配的引号或者括号，所以当再次序列化时像封闭样式规则那样不能对大的语法结构产生影响。

> 注意：自定义属性能包含'!important'结尾，但是这回自动被CSS解析器从属性值中移除，且使得自定义属性在CSS层叠中"important"。也就是说，在顶层禁止"!"字符并不是阻止'!important'不被使用，由于'!important'在语法检查之前就被移掉了。

> 注意：由于<任意值any-value>必须代表至少一个标记token，一个标记可能是空格。这意味着'--foo: ;'是有效的，且相应的'var(--foo)'能有一个空格作为他的替代值，但是'--foo:;'是无效的。

_例子3：_

> 例如，下边的就是一个合法的自定义属性：

```css
--foo: if(x > 5) this.width = 10;
```

> 由于这个值作为变量明显是无用的，因为他在任何的正常属性中都是无效的，他可以通过JavaScript读和执行。

自定义属性值以及var()函数的替代为自定义属性的值是区分大小写的，且必须在他们的原始的作者给定的套管casing中保存。（很多CSS值是不区分大小写的，用户代理能利用canonicalizing将他们放入一个单独的套管中，但是对自定义属性是不允许的。）

自定义属性的初始值是一个空值；也就是啥也没有。这个初始值和var()记法有一个特殊的交互，将在定义var()段落解释。

自定义属性是普通的属性，因此他们能在任何元素上声明，是通过正常的继承和层叠规则解决的，能有@media条件以及其他的条件规则，能在HTML的样式style属性中使用，能使用CSSOM（CSS对象模式CSS Object Model）读和写等等。

特别的是他们还能被过渡transitioned或者动画animated，但是因为用户代理没办法解释他们的内容，他们往往使用用于其他不能智能的以内插值替换的对值的"flips at 50%"行为。然而，在@keyframes规则中使用任何的自定义属性变成了animation-tainted污染动画，这影响了在一个动画属性中通过var()函数引用时如何对待。

_例子4：_

> 如下样式：

```css
:root {
  --header-color: #06c;
}
```

> 声明了在根元素上的一个名字为'--header-color'的自定义属性，且分配了一个值'#06c'。这个属性然后继承给了再文档中的其余的元素。他的值能用var()函数引用：

```css
h1 { background-color: var(--header-color); }
```

> 前边的规则和写'background-color:#06c;'是一样的，除了变量名使得颜色的由来更清晰了，且如果'var(--header-color)'如果在文档中的其他元素上使用，所有的使用都能通过修改在根元素上的'--header-color'属性一次更新。

_例子5：_

> 如果一个自定义属性被声明了多次，标准的层叠规则帮助解决他。变量往往从同样的元素上的相关的自定义属性的计算值中得到：

```
:root { --color: blue; }
div { --color: green; }
#alert { --color: red; }
* { color: var(--color); }

<p>I inherited blue from the root element!</p>
<div>I got green set directly on me!</div>
<div id='alert'>
  While I got red set directly on me!
  <p>I’m red too, because of inheritance!</p>
</div>
```

#### 解决循环依赖

自定义属性几乎完全是未经估值的，除了他们允许在他们的值中求'var()'函数的值。这能在使用var()引用他自身时或者两个或者更多的自定义属性互相引用彼此时创建循环依赖。

对于每一个元素，创建一个无直接依赖的图形，包含着每一个自定义属性的节点。如果自定义属性prop的值包含了一个引用属性var（包括在'var()'中的备用参数）的var()函数，在prop和var之间增加一个边界（边界有可能从一个自定属性到他自身）。如果在依赖的图中有一个循环，在这个循环中的所有的自定义属性必须计算为他们的初始值。

_例子6：_

> 这个例子展示了一个自定义属性安全地使用的变量：

```css
:root {
  --main-color: #c06;
  --accent-background: linear-gradient(to top, var(--main-color), white);
}
```

> 当'--main-color'改变时'--accent-background'属性将会自动更新。

_例子7：_

> 另一方面，这个例子展示了一个无效的彼此依赖变量的实例：

```css
:root {
  --one: calc(var(--two) + 20px);
  --two: calc(var(--one) - 20px);
}
```

> '--one'和'--two'现在计算为他们的初始值，而不是长度。

注意到在计算值的时间（发生在这个值被继承之前）自定义属性解决他们值中的任何'var()'函数是很重要的。一般情况下，只有当在同一个元素上的多个自定义属性彼此互相引用时才会发生循环依赖；在一个元素的元素树上较高的元素上定义的自定义属性永远不会和在元素树的较低元素上定义的属性发生循环引用。

_例子8：_

> 例如，给定的下边的结构，这些自定义属性不是循环的，且都定义了有效的变量：

```
<one><two><three /></two></one>
one   { --foo: 10px; }
two   { --bar: calc(var(--foo) + 10px); }
three { --foo: calc(var(--bar) + 10px); }
```

> < one >元素为'--foo'定义了一个值。< two >元素继承了这个值，且额外的用'foo'变量给'--bar'分配了一个值。最后，< three >元素在变量替代之后继承了'--bar'值，且然后依据那个值重新定义了'--foo'。由于那个值是继承的，'--bar'不在包含在< one >上定义的'--foo'属性的引用，所以使用'var(--bar)'变量定义'--foo'不是循环的，且实际上定义的值将最终算为'30px'。

### 使用层叠变量：'var()'记法

自定义属性的值能用'var()'函数取代到另一个属性的值中。'var()'的语法是：

	var() = var( <自定义属性名custom-property-name> [, <任何值any-value> ]? )

'var()'函数能取代在一个元素上的任何属性值的任何部分来使用。'var()'函数不能作为属性名，选择符或者除了属性值的其他任何东西来使用。（这样做通常会产生无效语法，或者其他一个值的意义和变量没有任何联系。）

函数的第一个参数是要被替换的自定义属性的名字。如果提供第二个参数了的话，他是一个备用值，当引用的自定义属性无效时作为替换值使用。

> 注意：和其他自定义属性很像，备用的语法允许逗号。例如，'var(--foo, red, blue)'定义了一个'red, blue'的备用；也就是第一个逗号和这个函数结尾之间的任何东西都被视为备用值。